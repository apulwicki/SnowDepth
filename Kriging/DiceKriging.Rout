
R version 3.2.3 (2015-12-10) -- "Wooden Christmas-Tree"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> ############################################################################
> #Dice Kriging
> ############################################################################
> 
> ## Libraries
> library(R.matlab)
R.matlab v3.6.1 (2016-10-19) successfully loaded. See ?R.matlab for help.

Attaching package: ‘R.matlab’

The following objects are masked from ‘package:base’:

    getOption, isOpen

> library(DiceKriging)
> library(DiceOptim)
> 
> 
> ## Load my data ##
> #residuals = readMat('/Users/Alexandra/Documents/SFU/Data/SnowDepth/Kriging/residuals.mat')
> residuals = readMat('/home/glaciology1/Documents/Data/SnowDepth/Kriging/residuals.mat')
> res = residuals$res
> utm = data.frame(residuals$utm)
> sizexy = residuals$sizexy
> 
> ## Model ##
> m = km(~1,design = utm, response = res, covtype = "matern5_2", nugget.estim = TRUE)

optimisation start
------------------
* estimation method   : MLE 
* optimisation method : BFGS 
* analytical gradient : used
* trend model : ~1
* covariance model : 
  - type :  matern5_2 
  - nugget : unknown homogenous nugget effect 
  - parameters lower bounds :  1e-10 1e-10 
  - parameters upper bounds :  7422.816 9181.425 
  - upper bound for alpha   :  1 
  - best initial criterion value(s) :  121.0655 

N = 3, M = 5 machine precision = 2.22045e-16
At X0, 0 variables are exactly at the bounds
At iterate     0  f=      -121.07  |proj g|=       0.5832
At iterate     1  f =      -121.07  |proj g|=     0.0059656
At iterate     2  f =      -121.07  |proj g|=    0.00084575
At iterate     3  f =      -121.07  |proj g|=     0.0017025
At iterate     4  f =      -121.07  |proj g|=     0.0093907
At iterate     5  f =      -121.07  |proj g|=      0.020663
At iterate     6  f =      -121.07  |proj g|=      0.039625
At iterate     7  f =      -121.07  |proj g|=      0.069862
At iterate     8  f =      -121.07  |proj g|=       0.11904
At iterate     9  f =      -121.07  |proj g|=        0.1983
At iterate    10  f =      -121.07  |proj g|=        0.3283
At iterate    11  f =      -121.08  |proj g|=       0.45322
At iterate    12  f =      -121.09  |proj g|=       0.46142
At iterate    13  f =      -121.11  |proj g|=       0.46979
At iterate    14  f =      -121.16  |proj g|=       0.46947
At iterate    15  f =      -121.25  |proj g|=       0.43697
At iterate    16  f =      -121.32  |proj g|=        0.0669
At iterate    17  f =      -121.33  |proj g|=        0.1673
At iterate    18  f =      -121.33  |proj g|=      0.059234
At iterate    19  f =      -121.33  |proj g|=     0.0031857
At iterate    20  f =      -121.33  |proj g|=    0.00090187
At iterate    21  f =      -121.33  |proj g|=    0.00012769

iterations 21
function evaluations 26
segments explored during Cauchy searches 22
BFGS updates skipped 0
active bounds at final generalized Cauchy point 0
norm of the final projected gradient 0.000127687
final function value -121.329

F = -121.329
final  value -121.328877 
converged
> #plot(m)
> #m
>  #Return model paramaters
>  maxLL = -m@logLik
>  intercept = m@trend.coef
>  nugget = m@covariance@nugget
>  model = data.frame(intercept, nugget, maxLL)
> 
>  #Cross validation (leave one out)
>  LOO = leaveOneOut.km(m, "SK",trend.reestim = TRUE)
>  
>  
> ## Kriging prediction surface ##
> x = seq(from = 0, to = (sizexy[1,2]-1)*40, by = 40)
> y = seq(from = 0, to = (sizexy[1,1]-1)*40, by = 40)
> grid = expand.grid(X1=x, X2 = y)
> pred.m = predict(m,grid,"SK")
> 
> 
> pred = matrix(pred.m$mean, sizexy[1,1], sizexy[1,2], byrow = TRUE)
> lower95 = matrix(pred.m$lower95, sizexy[1,1], sizexy[1,2], byrow = TRUE)
> upper95 = matrix(pred.m$upper95, sizexy[1,1], sizexy[1,2], byrow = TRUE)
> 
> writeMat('/home/glaciology1/Documents/Data/SnowDepth/Kriging/kriging.mat',
+          pred=pred, lower95=lower95, upper95=upper95, model = model, LOO = LOO,
+          fixNames=TRUE, matVersion="5", onWrite=NULL, verbose=FALSE)
> #  writeMat('/Users/Alexandra/Documents/SFU/Data/SnowDepth/Kriging/kriging.mat',
> #           pred=pred, lower95=lower95, upper95=upper95, model = model, LOO = LOO,
> #           fixNames=TRUE, matVersion="5", onWrite=NULL, verbose=FALSE)
> 
> ## Install and load rgl package
> #library(rgl)
> 
> ## Plot surface and observations
> #plot3d(X[,1],X[,2],res, xlim=c(0,3000),ylim=c(0,3000),zlim=0:1)
> #surface3d(x.grid,x.grid, matrix(pred.m$mean,n.grid,n.grid),col="light blue", alpha=0.5)
> 
> ## Plot surface and observations with intervals
> #  rglwidget()
> #plot3d(utm[,1],utm[,2],res, xlim=c(0,3000),ylim=c(0,3000),zlim=0:1)
> #surface3d(x,y, matrix(pred.m$mean, sizexy[1,1], sizexy[1,2]),col="light blue", alpha=0.5)
> #surface3d(x.grid,x.grid, matrix(pred.m$upper95,n.grid,n.grid),col="light blue", alpha=0.25)
> #surface3d(x.grid,x.grid, matrix(pred.m$lower95,n.grid,n.grid),col="light blue", alpha=0.25)
> #rgl.snapshot("filename.png")
> 
> proc.time()
   user  system elapsed 
  1.688   0.272   1.959 
